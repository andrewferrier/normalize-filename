#!/usr/bin/env python3

from datetime import datetime
from sys import platform as _platform
import argparse
import coloredlogs
import logging
import logging.handlers
import os.path
import re
import shutil
import sys
import termios
import tty

def main(argv, sysLogHandler, sysErrHandler):
    logger = logging.getLogger('normalize-filename')

    class ArgumentParser(argparse.ArgumentParser):
        def error(self, message):
            parser.print_help()
            raise FatalException(message)

    parser = ArgumentParser(description="Normalizes filenames in a variety of ways. "
                            "See https://github.com/andrewferrier/normalize-filename for more information.", add_help=False)

    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Make the output more verbose. This affects both the output logged to "
                        "syslog, as well as output to the console. Using this twice makes it doubly verbose.")

    parser.add_argument('-h', '--help', action='store_true',
                        help="Show some basic help information about how to use normalize-filename.")

    parser.add_argument('-n', '--dry-run', action='store_true', dest="dry_run",
                        help="Don't actually make any changes, just show them.")

    parser.add_argument('-i', '--interactive', action='store_true', dest="interactive",
                        help="Ask about each change before it is done.")

    parser.add_argument('-a', '--all', action='store_true', dest="all",
                        help="Affect all files, including those that begin with a .")

    parser.add_argument('--backup-directory', type=str, dest="backup_directory", default=None,
                        help="Put an original copy of each renamed file into a backup directory.")

    parser.add_argument('--no-prefix-date', action='store_true', dest="no_prefix_date", default=False,
                        help="Don't move or add a date to prefix each filename.")

    parser.add_argument('--no-recursive', action='store_true', dest="no_recursive", default=False,
                        help="Don't recurse into subdirectories of the directories specified on the command line.")

    time_option = parser.add_mutually_exclusive_group()

    time_option.add_argument('--now', action='store_const', dest="time_option", const="now",
                             help="Use the date and time now as the default "
                             "prefix for files that don't already have a date "
                             "and time.")

    time_option.add_argument('--latest', action='store_const', dest="time_option", const="latest",
                             help="Use the latest of ctime and mtime on a file "
                             "to find a date prefix for files that don't already "
                             "have a date and time.")

    time_option.add_argument('--earliest', action='store_const', dest="time_option", const="earliest",
                             help="Use the earliest of ctime and mtime on a file "
                             "to find a date prefix for files that don't already "
                             "have a date and time.")

    parser.set_defaults(time_option="now")

    class FilenamesAction(argparse.Action):
        def __call__(self, parser, args, values, option=None):
            args.filenames=values
            if (not args.help) and len(values) < 1:
                parser.error("You must specify some file or directory names.")

    parser.add_argument('filenames', metavar="filename", nargs='*', help='Filenames', action=FilenamesAction)

    args = parser.parse_args(argv[1:])

    if args.help:
        parser.print_help()
        return

    if sysLogHandler:
        if args.verbose > 1:
            sysLogHandler.setLevel(logging.DEBUG)
        elif args.verbose == 1:
            sysLogHandler.setLevel(logging.DEBUG)
        else:
            sysLogHandler.setLevel(logging.INFO)

    if sysErrHandler:
        if args.verbose > 1:
            sysErrHandler.setLevel(logging.DEBUG)
        elif args.verbose == 1:
            sysErrHandler.setLevel(logging.INFO)
        else:
            sysErrHandler.setLevel(logging.WARNING)

    if args.backup_directory and not os.path.exists(args.backup_directory):
        raise FatalException("Backup directory " + args.backup_directory + " does not exist.")

    try:
        for filename in args.filenames:
            if not os.path.exists(filename):
                raise FatalException(filename + " does not exist")

            if os.path.isdir(filename):
                if not args.no_recursive:
                    for root, dirs, files in os.walk(filename):
                        logger.debug("Working in directory " + root)
                        for sub_filename in files:
                            process_filename(os.path.join(root, sub_filename), args)
            else:
                process_filename(filename, args)
    except QuitException:
        pass

def process_filename(filename, args):
    logger = logging.getLogger("normalize-filename")

    logger.debug("Processing filename " + filename)
    original_filename = filename
    basename = os.path.basename(filename)

    if basename.startswith(".") and (not args.all):
        logger.info("Skipping " + filename + " as it begins with .")
        return

    if(not args.no_prefix_date):
        def replacement(matchobj):
            return (matchobj.group(2) + "-" +
                    matchobj.group(3) +
                    (("-" + matchobj.group(4)) if matchobj.group(4) is not None else '') +
                    (("-" + matchobj.group(1)) if matchobj.group(1) != '' else '') +
                    (matchobj.group(5) if matchobj.group(5) != '' else ''))

        (non_extension, extension) = os.path.splitext(basename)
        (basename, number_of_subs) = re.subn(r"^(.*?)[-_]?" +
                                             r"((?:19|20)\d\d)" +
                                             r"[-_]?((?:[01])\d)" +
                                             r"(?:[-_]?((?:[0123])\d))?" +
                                             r"((?:[-_]|T)?.*)$",
                                             replacement,
                                             non_extension)
        basename = basename.strip() + extension

        assert(number_of_subs <= 1)

        if(number_of_subs == 0):
            logger.debug("Didn't find date")
            ctime = datetime.fromtimestamp(os.path.getctime(filename))
            mtime = datetime.fromtimestamp(os.path.getmtime(filename))

            if(args.time_option == "now"):
                timetouse = datetime.now()
            elif(args.time_option == "earliest"):
                if(ctime < mtime):
                    timetouse = ctime
                else:
                    timetouse = mtime
            else:
                if(ctime < mtime):
                    timetouse = mtime
                else:
                    timetouse = ctime

            basename = timetouse.strftime("%Y-%m-%d-") + basename

    filename = os.path.join(os.path.dirname(original_filename), basename)
    logger.debug("New filename " + filename)

    if not filename == original_filename:
        move_it = True

        if args.interactive:
            move_it = ask_yes_no("Move " + original_filename + " to " + filename + " [y/n/q]?")

        if move_it:
            if not args.dry_run:
                if args.backup_directory:
                    shutil.copy(original_filename, args.backup_directory)
                    logger.info(original_filename + " copied to " + filename)

                shutil.move(original_filename, filename)
                logger.info(original_filename + " moved to " + filename)
            else:
                if args.backup_directory:
                    logger.info("Not creating a backup copy of " + original_filename +
                                " to " + args.backup_directory + "; dry run.")

                logger.info("Not moving " + original_filename + " to " + filename + "; dry run.")
    else:
        logger.info("No changes to " + original_filename)

def ask_yes_no(prompt):
    while True:
        print(prompt, end="", flush=True)
        try:
            key = readchar().lower()
        except KeyboardInterrupt:
            raise QuitException()
        print(str(key, "utf-8"))
        if key == b'y':
            return True
        elif key == b'n':
            return False
        elif key == b'q':
            raise QuitException()

def readchar(wait_for_char=True):
    assert(sys.platform.startswith('linux') or sys.platform == 'darwin')
    try:
        old_settings = termios.tcgetattr(sys.stdin)
        tty.setcbreak(sys.stdin.fileno())
        try:
            if wait_for_char or select.select([sys.stdin, ], [], [], 0.0)[0]:
                return os.read(sys.stdin.fileno(), 1)
        finally:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
    except termios.error:
        return os.read(sys.stdin.fileno(), 1)
    return None

warning_pending = False

def warning(message):
    global warning_pending
    logger = logging.getLogger("normalize-filename")
    logger.warning(message)
    warning_pending = True

class FatalException(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)

class QuitException(Exception):
    pass

if __name__ == "__main__":
    logger = logging.getLogger("normalize-filename")
    logger.propagate = False
    logger.setLevel(logging.DEBUG)

    coloredlogs.install(level=logging.DEBUG)

    if _platform == "linux" or _platform == "linux2":
        sysLogAddress = '/dev/log'
    elif _platform == "darwin":
        sysLogAddress = '/var/run/syslog'
    else:
        print("Unsupported platform.")
        sys.exit(3)

    sysLogHandler = logging.handlers.SysLogHandler(address=sysLogAddress)
    sysLogHandler.setLevel(logging.INFO)
    sysLogFormatter = logging.Formatter('%(pathname)s[%(process)d] %(levelname)s %(lineno)d %(message)s')
    sysLogHandler.setFormatter(sysLogFormatter)
    logger.addHandler(sysLogHandler)

    sysErrHandler = coloredlogs.ColoredStreamHandler(stream=sys.stderr, show_timestamps=False, show_hostname=False, show_name=False, show_severity=False)
    sysErrHandler.setLevel(logging.WARNING)
    logger.addHandler(sysErrHandler)

    try:
        main(sys.argv, sysLogHandler, sysErrHandler)
    except FatalException as e:
        logger.error(e.value)
        sys.exit(2)
    except:
        traceback.print_exc()
        sys.exit(3)

    if warning_pending:
        sys.exit(1)

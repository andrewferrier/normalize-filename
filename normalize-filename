#!/usr/bin/env python3

from datetime import datetime
from sys import platform as _platform
import argparse
import coloredlogs
import logging
import logging.handlers
import os.path
import re
import shutil
import sys
import termios
import tty

BASENAME_EXCLUDE_PATTERNS = frozenset([r"\..*", "Icon\r", ".*\.lo?ck"])

FULLNAME_EXCLUDE_PATTERNS = frozenset([r".*\.git/.*",
                                       r".*\.svn/.*",
                                       r".*\.hg/.*",
                                       r".*\.bzr/.*"])

YEAR = ""

def main(argv, sysLogHandler, sysErrHandler):
    logger = logging.getLogger('normalize-filename')

    class ArgumentParser(argparse.ArgumentParser):
        def error(self, message):
            parser.print_help()
            raise FatalException(message)

    parser = ArgumentParser(description="Normalizes filenames in a variety of ways. "
                            "See https://github.com/andrewferrier/normalize-filename for more information.", add_help=False)

    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Make the output more verbose. This affects both the output logged to "
                        "syslog, as well as output to the console. Using this twice makes it doubly verbose.")

    parser.add_argument('-h', '--help', action='store_true',
                        help="Show some basic help information about how to use normalize-filename.")

    parser.add_argument('-n', '--dry-run', action='store_true', dest="dry_run",
                        help="Don't actually make any changes, just show them.")

    parser.add_argument('-i', '--interactive', action='store_true', dest="interactive",
                        help="Ask about each change before it is done.")

    parser.add_argument('-a', '--all', action='store_true', dest="all",
                        help="Affect all files, including those that by default would be excluded.")

    parser.add_argument('-f', '--force', action='store_true', dest='force',
                        help="Overwrite target files even if they already "
                        "exist (USE WITH CAUTION, consider using --dry-run "
                        "first)")

    parser.add_argument('-t', '--add-time', action='store_true', dest='add_time',
                        help='If a time is not found in the filename, add one '
                        'when adding the date prefix.')

    parser.add_argument('--backup-directory', type=str, dest="backup_directory", default=None,
                        help="Put an original copy of each renamed file into a backup directory.")

    parser.add_argument('--no-recursive', action='store_true', dest="no_recursive", default=False,
                        help="Don't recurse into subdirectories of any directories specified on the command line.")

    parser.add_argument('--max-years-ahead', type=int, dest='max_years_ahead', default=5,
                        help='Consider years in filenames further ahead than this number to be invalid. Defaults to 5.')

    parser.add_argument('--max-years-behind', type=int, dest='max_years_behind', default=30,
                        help='Consider years in filenames further behind than this number to be invalid. Defaults to 30.')

    time_option = parser.add_mutually_exclusive_group()

    time_option.add_argument('--now', action='store_const', dest="time_option", const="now",
                             help="Use the date and time now as the default "
                             "prefix for files that don't already have a date "
                             "and time.")

    time_option.add_argument('--latest', action='store_const', dest="time_option", const="latest",
                             help="Use the latest of ctime and mtime on a file "
                             "to find a date prefix for files that don't already "
                             "have a date and time.")

    time_option.add_argument('--earliest', action='store_const', dest="time_option", const="earliest",
                             help="Use the earliest of ctime and mtime on a file "
                             "to find a date prefix for files that don't already "
                             "have a date and time. This is the default if you "
                             "don't specify --now or --latest.")

    parser.set_defaults(time_option="earliest")

    class FilenamesAction(argparse.Action):
        def __call__(self, parser, args, values, option=None):
            args.filenames=values
            if (not args.help) and len(values) < 1:
                parser.error("You must specify some file or directory names.")

    parser.add_argument('filenames', metavar="filename", nargs='*', help='Filenames', action=FilenamesAction)

    args = parser.parse_args(argv[1:])

    if args.help:
        parser.print_help()
        return

    if sysLogHandler:
        if args.verbose > 1:
            sysLogHandler.setLevel(logging.DEBUG)
        elif args.verbose == 1:
            sysLogHandler.setLevel(logging.DEBUG)
        else:
            sysLogHandler.setLevel(logging.INFO)

    if sysErrHandler:
        if args.verbose > 1:
            sysErrHandler.setLevel(logging.DEBUG)
        elif args.verbose == 1:
            sysErrHandler.setLevel(logging.INFO)
        else:
            sysErrHandler.setLevel(logging.WARNING)

    if args.backup_directory and not os.path.exists(args.backup_directory):
        raise FatalException("Backup directory " + args.backup_directory + " does not exist.")

    global YEAR

    year_now = datetime.now().year
    year_list = [str(year) for year in range(year_now - args.max_years_behind, year_now + args.max_years_ahead)]
    YEAR = r"(" + '|'.join(year_list) + r")"

    try:
        for filename in args.filenames:
            if not os.path.exists(filename):
                raise FatalException(filename + " specified on the command line does not exist.")

            if os.path.isdir(filename):
                if not args.no_recursive:
                    for root, dirs, files in os.walk(filename):
                        logger.debug("Walking directory tree, working in directory " + root)
                        for sub_filename in files:
                            process_filename(os.path.join(root, sub_filename), args)
                else:
                    for item in os.listdir(filename):
                        fullitem = os.path.join(filename, item)
                        if os.path.isfile(fullitem):
                            process_filename(fullitem, args)
                        else:
                            logger.info("Skipping subdirectory " + fullitem)
            else:
                process_filename(filename, args)
    except QuitException:
        pass

def process_filename(filename, args):
    logger = logging.getLogger("normalize-filename")

    logger.debug("Processing filename " + filename)
    original_filename = filename
    basename = os.path.basename(filename)

    if not args.all:
        match = False

        for EXCLUDE_PATTERN in BASENAME_EXCLUDE_PATTERNS:
            if re.fullmatch(EXCLUDE_PATTERN, basename):
                match = True
                break

        if not match:
            for EXCLUDE_PATTERN in FULLNAME_EXCLUDE_PATTERNS:
                if re.fullmatch(EXCLUDE_PATTERN, filename):
                    match = True
                    break

        if match:
            logger.info("Skipping " + filename.strip() + " as it matches pattern " + EXCLUDE_PATTERN)
            return

    def replacement(matchobj):
        year = matchobj.group('year') if matchobj.group('year') is not None else matchobj.group('year2')
        month = matchobj.group('month') if matchobj.group('month') is not None else matchobj.group('month2')
        day = matchobj.group('day') if matchobj.group('day') is not None else matchobj.group('day2')

        return (year + "-" +
                month +
                (("-" + day) if day is not None else '') +
                (("T" + matchobj.group('hour')) if matchobj.group('hour') is not None else '') +
                (("-" + matchobj.group('minute')) if matchobj.group('minute') is not None else '') +
                (("-" + matchobj.group('second')) if matchobj.group('second') is not None else '') +
                (("-" + matchobj.group('prefix')) if matchobj.group('prefix') != '' else '') +
                (matchobj.group('suffix') if matchobj.group('suffix') != '' else ''))

    (non_extension, extension) = os.path.splitext(basename)

    MONTH = r"(0\d|1[012])"
    DAY = r"([012]\d|3[01])"
    HOUR = r"([01]\d|2[0123])"
    MINUTE = SECOND = r"[012345]\d"

    YMD_SEPARATOR = r"[-_\s]?"
    HMS_SEPARATOR = r"[-_.\s]?"
    DATE_TIME_SEPARATOR = r"([-_T\s]|\sat\s)"

    (basename, number_of_subs) = re.subn(r"^(?P<prefix>.*?)[-_]?" +
                                         r"((?P<year>" + YEAR + r")" +
                                         YMD_SEPARATOR + r"(?P<month>" + MONTH + r")" +
                                         r"(" + YMD_SEPARATOR + r"(?P<day>" + DAY + r"))?|" +
                                         r"(?P<day2>" + DAY + r")" +
                                         r"-(?P<month2>" + MONTH + r")" +
                                         r"-(?P<year2>" + YEAR + r"))" +
                                         r"(" + DATE_TIME_SEPARATOR + r"(?P<hour>" + HOUR + r")"
                                         r"(" + HMS_SEPARATOR + r"(?P<minute>" + MINUTE + r")"
                                         r"(" + HMS_SEPARATOR + r"(?P<second>" + SECOND + r"))?)?)?"
                                         r"(?P<suffix>.*)$",
                                         replacement,
                                         non_extension)
    basename = basename.strip() + extension

    assert(number_of_subs <= 1)

    if(number_of_subs == 0):
        logger.debug("Didn't find date or time")
        ctime = datetime.fromtimestamp(os.path.getctime(filename))
        mtime = datetime.fromtimestamp(os.path.getmtime(filename))

        if(args.time_option == "now"):
            timetouse = datetime.now()
        elif(args.time_option == "earliest"):
            if(ctime < mtime):
                timetouse = ctime
            else:
                timetouse = mtime
        else:
            if(ctime < mtime):
                timetouse = mtime
            else:
                timetouse = ctime

        if args.add_time:
            basename = timetouse.strftime("%Y-%m-%dT%H-%M-%S-") + basename
        else:
            basename = timetouse.strftime("%Y-%m-%d-") + basename

    filename = os.path.join(os.path.dirname(original_filename), basename)
    logger.debug("New filename " + filename)

    if not filename == original_filename:
        if os.path.exists(filename) and not args.force:
            raise FatalException("Want to move " + original_filename.strip() + " to " + filename + ", but it already exists.")

        original_basename = os.path.basename(original_filename)

        if (args.backup_directory and
                os.path.exists(os.path.join(args.backup_directory, original_basename)) and
                not args.force):
            raise FatalException(original_basename.strip() + " already exists in backup directory " + args.backup_directory + "; not renaming.")

        move_it = True

        if args.interactive:
            move_it = ask_yes_no("Move " + original_filename.strip() + " to .../" + basename + " [y/n/e/q]?")

        if move_it:
            if not args.dry_run:
                if args.backup_directory:
                    shutil.copy(original_filename, args.backup_directory)
                    logger.info(original_filename + " copied to " + filename)

                shutil.move(original_filename, filename)
                logger.info(original_filename + " moved to " + filename)
            else:
                if args.backup_directory:
                    logger.info("Not creating a backup copy of " + original_filename.strip() +
                                " to " + args.backup_directory + "; dry run.")

                logger.info("Not moving " + original_filename.strip() + " to " + filename + "; dry run.")
    else:
        logger.info("No changes to " + original_filename.strip())

def ask_yes_no(prompt):
    while True:
        print(prompt, end="", flush=True)
        try:
            key = readchar().lower()
        except KeyboardInterrupt:
            raise QuitException()
        print(str(key, "utf-8"))
        if key == b'y':
            return True
        elif key == b'n':
            return False
        elif key == b'q':
            raise QuitException()

def readchar(wait_for_char=True):
    assert(sys.platform.startswith('linux') or sys.platform == 'darwin')
    try:
        old_settings = termios.tcgetattr(sys.stdin)
        tty.setcbreak(sys.stdin.fileno())
        try:
            if wait_for_char or select.select([sys.stdin, ], [], [], 0.0)[0]:
                return os.read(sys.stdin.fileno(), 1)
        finally:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
    except termios.error:
        return os.read(sys.stdin.fileno(), 1)
    return None

warning_pending = False

def warning(message):
    global warning_pending
    logger = logging.getLogger("normalize-filename")
    logger.warning(message)
    warning_pending = True

class FatalException(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)

class QuitException(Exception):
    pass

if __name__ == "__main__":
    logger = logging.getLogger("normalize-filename")
    logger.propagate = False
    logger.setLevel(logging.DEBUG)

    coloredlogs.install(level=logging.DEBUG)

    if _platform == "linux" or _platform == "linux2":
        sysLogAddress = '/dev/log'
    elif _platform == "darwin":
        sysLogAddress = '/var/run/syslog'
    else:
        print("Unsupported platform.")
        sys.exit(3)

    sysLogHandler = logging.handlers.SysLogHandler(address=sysLogAddress)
    sysLogHandler.setLevel(logging.INFO)
    sysLogFormatter = logging.Formatter('%(pathname)s[%(process)d] %(levelname)s %(lineno)d %(message)s')
    sysLogHandler.setFormatter(sysLogFormatter)
    logger.addHandler(sysLogHandler)

    sysErrHandler = coloredlogs.ColoredStreamHandler(stream=sys.stderr, show_timestamps=False, show_hostname=False, show_name=False, show_severity=False)
    sysErrHandler.setLevel(logging.WARNING)
    logger.addHandler(sysErrHandler)

    try:
        main(sys.argv, sysLogHandler, sysErrHandler)
    except FatalException as e:
        logger.error(e.value)
        sys.exit(2)
    except:
        traceback.print_exc()
        sys.exit(3)

    if warning_pending:
        sys.exit(1)
